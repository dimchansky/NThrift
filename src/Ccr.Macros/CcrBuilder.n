using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.ComputationExpressions;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using TExpr = Nemerle.Compiler.Typedtree.TExpr;

namespace NThrift.Ccr.Macros
{  
    [Record]
    public class CcrBuilder : ComputationBuilder
    {
        typer : Typer;
        dispatcherQueue : PExpr;
        [RecordIgnore] resultPort : Name = Macros.NewSymbol ("resultPort");

        public override Return (expr : PExpr) : PExpr
        {
            match (expr)
            {
                | <[ () ]>          =>  <[ $(resultPort : name).Post(Microsoft.Ccr.Core.EmptyValue.SharedInstance); ]>
                | PExpr.Literal(_)
                | PExpr.Ref(_)      =>  <[ $(resultPort : name).Post($expr); ]>
                | _                 =>  <[ 
                                            try
                                            {
                                                $(resultPort : name).Post($expr);
                                            }
                                            catch
                                            {
                                                ex => $(resultPort : name).Post(ex);
                                            }
                                        ]>                
            }           
        }

        public override ReturnComp (expr : PExpr) : PExpr
        {
            ignore (expr);
            Message.FatalError (expr.Location, "The ccr comprehension doesn't support the ReturnComp method.")
        }

        public override Yield (expr : PExpr) : PExpr
        {
            ignore (expr);
            Message.FatalError (expr.Location, "The ccr comprehension doesn't support the Yield method.")
        }

        public override YieldComp (expr : PExpr) : PExpr
        {
            ignore (expr);
            Message.FatalError (expr.Location, "The ccr comprehension doesn't support the YieldComp method.")
        }

        public override Bind (expr : PExpr, name : PExpr, cont : PExpr) : PExpr
        {
            Macros.DefineCTX(typer);

            ignore (expr);
            ignore (name);
            ignore (cont);           
            if (dispatcherQueue != null)
            {               
                def tExpr = typer.TypeExpr(expr);

                def makeResult(tExpr : TExpr) : PExpr
                {
                    def bindPortSet = Macros.NewSymbol ("bindPortSet");
                    def resultValue = Macros.NewSymbol ("resultValue");
                    def resultException = Macros.NewSymbol ("resultException");
                    def tBindExpr = <[ ttype: Microsoft.Ccr.Core.PortSet[_, System.Exception] ]> ;
                    
                    if (tBindExpr.TryUnify(tExpr.Type))
                    {
                        tBindExpr.ForceUnify(tExpr.Type);
                        def resultType = tBindExpr.args.Head;
                        <[
                            def $(bindPortSet : name) = $(tExpr : typed);

                            mutable $(resultValue : name) : $(resultType : typed);
                            if ($(bindPortSet : name).P0.Test(out $(resultValue : name)))
                            {
                                ($name => $cont)($(resultValue : name));
                            }
                            else
                            {
                                mutable $(resultException : name) : System.Exception;
                                if($(bindPortSet : name).P1.Test(out $(resultException : name)))
                                {
                                    $(resultPort : name).Post($(resultException : name));
                                }
                                else
                                {
                                    Microsoft.Ccr.Core.Arbiter.Activate($dispatcherQueue,
                                        Microsoft.Ccr.Core.Arbiter.Choice($(bindPortSet : name),
                                            $name => $cont,
                                            ex => $(resultPort : name).Post(ex)));
                                }
                            }
                        ]>
                    }
                    else
                    {
                        Message.FatalError(expr.Location, "'$expr' must be of type Microsoft.Ccr.Core.PortSet[_,System.Exception]");
                    }
                    
                }

                match(tExpr.Type.Hint)
                {
                    | Some(_) => makeResult(tExpr)
                    | _       => typer.DelayMacro(lastTry =>
                                    match(tExpr.Type.Hint)
                                    {
                                        | Some(_) => Some(makeResult(tExpr))
                                        | _       => when (lastTry) Message.Error(expr.Location, $"Cannot infer type of '$expr'");
                                                     None()
                                    }
                                 );
                }
            }
            else
            {
                Message.FatalError (expr.Location, "In order to use Bind method you must specify dispatcher queue as ccr comprehension parameter.")
            }
        }

        public override Delay (expr : PExpr) : PExpr
        {
            ignore (expr);
            Message.FatalError (expr.Location, "The ccr comprehension doesn't support the Delay method.")
        }

        public override Combine (expr1 : PExpr, expr2 : PExpr) : PExpr 
        {
            ignore (expr1);
            ignore (expr2);
            Message.FatalError (expr1.Location, "The ccr comprehension doesn't support the Combine method.")
        }

        public override Run (expr : PExpr) : PExpr
        {
            <[
                {
                    def $(resultPort : name) = NThrift.Ccr.ResultFailurePort();
                    $expr;
                    $(resultPort : name);
                }
            ]>
        }

        public override Zero () : PExpr
        {
            <[()]>
        }

        public override While (pred : PExpr, body : PExpr) : PExpr
        {
            ignore (pred);
            ignore (body);
            Message.FatalError (pred.Location, "The ccr comprehension doesn't support the While method.")
        }

        public override ForEach (name : PExpr, coll : PExpr, body : PExpr) : PExpr
        {
            ignore (name);
            ignore (coll);
            ignore (body);
            Message.FatalError (name.Location, "The ccr comprehension doesn't support the ForEach method.")
        }

        protected override ForEach (coll : PExpr, cont : PExpr) : PExpr
        {
            ignore (coll);
            ignore (cont);
            Message.FatalError (coll.Location, "The ccr comprehension doesn't support the ForEach method.")
        }

        public override For (init : PExpr, cond : PExpr, change : PExpr, body : PExpr) : PExpr
        {
            ignore (init);
            ignore (cond);
            ignore (change);
            ignore (body);
            Message.FatalError (init.Location, "The ccr comprehension doesn't support the For method.")
        }

        public override DoWhile (pred : PExpr, body : PExpr) : PExpr
        {
            ignore (pred);
            ignore (body);
            Message.FatalError (pred.Location, "The ccr comprehension doesn't support the DoWhile method.")
        }

        public override TryFinally (body : PExpr, handler : PExpr) : PExpr
        {
            ignore (body);
            ignore (handler);            
            Message.FatalError (body.Location, "The ccr comprehension doesn't support the TryFinally method.")
        }

        public override TryCatch (body : PExpr, cases : list [TryCase]) : PExpr
        {
            ignore (body);
            ignore (cases);                        
            Message.FatalError (body.Location, "The ccr comprehension doesn't support the TryCatch method.")
        }

        protected override TryCatch (body : PExpr, cont : PExpr) : PExpr
        {
            ignore (body);
            ignore (cont);
            Message.FatalError (body.Location, "The ccr comprehension doesn't support the TryCatch method.")
        }

        public override Using (expr : PExpr, name : PExpr, body : PExpr) : PExpr
        {
            ignore (expr);
            ignore (name);
            ignore (body);
            Message.FatalError (expr.Location, "The ccr comprehension doesn't support the Using method.")
        }        
    }    
}
