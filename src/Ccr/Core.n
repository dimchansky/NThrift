using System;

using Nemerle.Assertions;
using Nemerle.Utility;

using Microsoft.Ccr.Core;    

namespace NThrift.Ccr
{
    public type ResultFailurePort[TResult] = PortSet[TResult, Exception];
    public type VoidFailurePort = ResultFailurePort[EmptyValue];
    
    public enum CAsyncType : byte
    {
        | CompletedResult    = 0
        | CompletedException = 1
        | Async              = 2
    }

    [Record]
    public struct CAsync
    {
        [Accessor(flags=Internal)] type : CAsyncType;
        [Accessor(flags=Internal)] exception : System.Exception;
        [Accessor(flags=Internal)] resultPort : VoidFailurePort;
        
        internal static CreateResult(): CAsync
        {
            CAsync(CAsyncType.CompletedResult, null, null)
        }
        
        internal static CreateException(ex : System.Exception) : CAsync
        {
            CAsync(CAsyncType.CompletedException, ex, null)
        }
        
        internal static CreateAsync(resultPort : VoidFailurePort) : CAsync
        {
            CAsync(CAsyncType.Async, null, resultPort);
        }

        /// CAsync can be bind only to one result port
        public BindToPort([NotNull]dq : DispatcherQueue, [NotNull]port : VoidFailurePort) : void
        {
            match (type)
            {
                | CAsyncType.CompletedResult      => 
                    port.Post(EmptyValue.SharedInstance)
                                                                                
                | CAsyncType.CompletedException   => 
                    assert2(exception != null);
                    port.Post(exception)

                | CAsyncType.Async                =>
                    assert2(resultPort != null);
                    
                    // check if result port already has result or exception
                    mutable result;                    
                    if (resultPort.P0.Test(out result)) // test for result
                    {
                        port.Post(result);
                    }
                    else
                    {
                        mutable ex;
                        if (resultPort.P1.Test(out ex)) // test for exception
                        {
                            port.Post(ex);
                        }
                        else
                        {
                            // port has no result or exception, activating continuation
                            Arbiter.Activate(dq,
                                Arbiter.Choice(resultPort,
                                    port.Post(_),
                                    ex => {
                                            assert2(ex != null);
                                            port.Post(ex)
                                          }))                            
                        }
                    }                    
            }                        
        }
        
        // CAsync can be transformed to port only once
        public ToPort([NotNull]dq : DispatcherQueue) : VoidFailurePort
        {
            def port = VoidFailurePort();
            this.BindToPort(dq, port);
            port;
        }        
        
        public static FromBeginEnd(begin : AsyncCallback -> IAsyncResult, end : IAsyncResult -> void) : CAsync
        {
            def resultPort = VoidFailurePort();
            
            try
            {
                _ = begin(ar =>
                            try
                            {
                                end(ar);
                                resultPort.Post(EmptyValue.SharedInstance);
                            }
                            catch
                            {
                                ex => resultPort.Post(ex);
                            });
                            
                CAsync.CreateAsync(resultPort);
            }
            catch
            {
                ex => CAsync.CreateException(ex);
            }                       
        }
    }    
    
    [Record]
    public struct CAsync[TResult]
    {
        [Accessor(flags=Internal)] type : CAsyncType;
        [Accessor(flags=Internal)] result : TResult;
        [Accessor(flags=Internal)] exception : System.Exception;
        [Accessor(flags=Internal)] resultPort : ResultFailurePort[TResult];
        
        internal static CreateResult(result : TResult): CAsync[TResult]
        {
            CAsync(CAsyncType.CompletedResult, result, null, null)
        }
        
        internal static CreateException(ex : System.Exception) : CAsync[TResult]
        {
            CAsync(CAsyncType.CompletedException, default(TResult), ex, null)
        }
        
        internal static CreateAsync(resultPort : ResultFailurePort[TResult]) : CAsync[TResult]
        {
            CAsync(CAsyncType.Async, default(TResult), null, resultPort);
        }
        
        /// CAsync can be bind only to one result port
        public BindToPort([NotNull]dq : DispatcherQueue, [NotNull]port : ResultFailurePort[TResult]) : void
        {
            match (type)
            {
                | CAsyncType.CompletedResult      => 
                    port.Post(result)
                                                                                
                | CAsyncType.CompletedException   => 
                    assert2(exception != null);
                    port.Post(exception)

                | CAsyncType.Async                =>
                    assert2(resultPort != null);
                    
                    // check if result port already has result or exception
                    mutable result;                    
                    if (resultPort.P0.Test(out result)) // test for result
                    {
                        port.Post(result);
                    }
                    else
                    {
                        mutable ex;
                        if (resultPort.P1.Test(out ex)) // test for exception
                        {
                            port.Post(ex);
                        }
                        else
                        {
                            // port has no result or exception, activating continuation
                            Arbiter.Activate(dq,
                                Arbiter.Choice(resultPort,
                                    port.Post(_),
                                    ex => {
                                            assert2(ex != null);
                                            port.Post(ex)
                                          }))                            
                        }
                    }                    
            }                        
        }
        
        // CAsync can be transformed to port only once
        public ToPort([NotNull]dq : DispatcherQueue) : ResultFailurePort[TResult]
        {
            def port = ResultFailurePort();
            this.BindToPort(dq, port);
            port;
        }        
        
        public static FromBeginEnd(begin : AsyncCallback -> IAsyncResult, end : IAsyncResult -> TResult) : CAsync[TResult]
        {
            def resultPort = ResultFailurePort();
            
            try
            {
                _ = begin(ar =>
                            try
                            {
                                def result = end(ar);
                                resultPort.Post(result);
                            }
                            catch
                            {
                                ex => resultPort.Post(ex);
                            });
                            
                CAsync.CreateAsync(resultPort);
            }
            catch
            {
                ex => CAsync.[TResult].CreateException(ex);
            }                       
        }        
    }   
}
